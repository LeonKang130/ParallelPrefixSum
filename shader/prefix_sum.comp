#version 460 core
#extension GL_ARB_shader_ballot : require

#define STATUS_X 0
#define STATUS_B 1 // block-level aggregate ready
#define STATUS_G 2 // grid-level prefix sum ready
#define STATUS_FLAG_LEN 2
#define STATUS_FLAG_MASK 3

#define THREADS_PER_WARP 32
#define WARPS_PER_BLOCK 32
#define THREADS_PER_BLOCK (THREADS_PER_WARP * WARPS_PER_BLOCK)
#define ELEMENTS_PER_THREAD 2
#define ELEMENTS_PER_WARP (ELEMENTS_PER_THREAD * THREADS_PER_WARP)
#define ELEMENTS_PER_BLOCK (ELEMENTS_PER_WARP * WARPS_PER_BLOCK)

layout(binding = 0) restrict readonly buffer InputBuffer {
    int input_data[];
};

layout(binding = 1) restrict coherent buffer OutputBuffer {
    int output_data[];
};

layout(local_size_x = THREADS_PER_BLOCK, local_size_y = 1, local_size_z = 1) in;

shared int warp_level[WARPS_PER_BLOCK][ELEMENTS_PER_WARP];
shared int block_level[WARPS_PER_BLOCK];

void main() {
    int thread_index = int(gl_LocalInvocationID.x) % THREADS_PER_WARP;
    int warp_index = int(gl_LocalInvocationID.x) / THREADS_PER_WARP;
    int block_index = int(gl_GlobalInvocationID.x) / THREADS_PER_BLOCK;
    int current_block_offset = block_index * ELEMENTS_PER_BLOCK;
    int current_warp_offset = current_block_offset + warp_index * ELEMENTS_PER_WARP;
    // write into shared memory, reg1 and reg2 are saved for later usage
    int reg1 = input_data[current_warp_offset + thread_index];
    int reg2 = input_data[current_warp_offset + THREADS_PER_WARP + thread_index];
    warp_level[warp_index][thread_index] = reg1;
    warp_level[warp_index][THREADS_PER_WARP + thread_index] = reg2;
    // warp level prefix sum
    int offset = 0;
    #pragma unroll
    for (int d = THREADS_PER_WARP; d != 0; d >>= 1) {
        if (thread_index < d) {
            int ai = ((thread_index << 1 | 1) << offset) - 1;
            int bi = (thread_index + 1 << offset + 1) - 1;
            warp_level[warp_index][bi] += warp_level[warp_index][ai];
        }
        offset++;
    }
    if (thread_index == 0) warp_level[warp_index][ELEMENTS_PER_WARP - 1] = 0;
    #pragma unroll
    for (uint d = 1; d <= THREADS_PER_WARP; d <<= 1) {
        offset--;
        if (thread_index < d) {
            int ai = ((thread_index << 1 | 1) << offset) - 1;
            int bi = (thread_index + 1 << offset + 1) - 1;
            int t = warp_level[warp_index][ai];
            warp_level[warp_index][ai] = warp_level[warp_index][bi];
            warp_level[warp_index][bi] += t;
        }
    }
    warp_level[warp_index][thread_index] += reg1;
    warp_level[warp_index][THREADS_PER_WARP + thread_index] += reg2;
    if (thread_index == 0) block_level[warp_index] = warp_level[warp_index][ELEMENTS_PER_WARP - 1];
    memoryBarrierShared();
    barrier();
    if (warp_index == 0) {
        // block level prefix sum
        #pragma unroll
        for (int d = WARPS_PER_BLOCK >> 1; d != 0; d >>= 1) {
            if (thread_index < d) {
                int ai = ((thread_index << 1 | 1) << offset) - 1;
                int bi = (thread_index + 1 << offset + 1) - 1;
                block_level[bi] += block_level[ai];
            }
            offset++;
        }
        if (thread_index == 0) block_level[WARPS_PER_BLOCK - 1] = 0;
        #pragma unroll
        for (int d = 1; d <= WARPS_PER_BLOCK >> 1; d <<= 1) {
            offset--;
            if (thread_index < d) {
                int ai = ((thread_index << 1 | 1) << offset) - 1;
                int bi = (thread_index + 1 << offset + 1) - 1;
                int t = block_level[ai];
                block_level[ai] = block_level[bi];
                block_level[bi] += t;
            }
        }
        #pragma unroll
        for (int current_warp = 0; current_warp < WARPS_PER_BLOCK; current_warp++) {
            int reg3 = block_level[current_warp];
            warp_level[current_warp][thread_index] += reg3;
            warp_level[current_warp][THREADS_PER_WARP + thread_index] += reg3;
        }
        output_data[current_block_offset + (thread_index + 1) * ELEMENTS_PER_WARP - 1] = warp_level[thread_index][ELEMENTS_PER_WARP - 1] << STATUS_FLAG_LEN | STATUS_B;
        int block_prefix_sum = 0;
        if (thread_index == 0) {
            for (int probe_block = block_index - 1; probe_block != -1; probe_block--) {
                int probe_location = (probe_block + 1) * ELEMENTS_PER_BLOCK - 1;
                int probe_result = output_data[probe_location];
                int status_flag = probe_result & STATUS_FLAG_MASK;
                while (status_flag == STATUS_X) {
                    probe_result = output_data[probe_location];
                    status_flag = probe_result & STATUS_FLAG_MASK;
                }
                block_prefix_sum += probe_result >> STATUS_FLAG_LEN;
                if (status_flag == STATUS_G) break;
            }
        }
        block_prefix_sum = readFirstInvocationARB(block_prefix_sum);
        #pragma unroll
        for (int current_warp = 0; current_warp < WARPS_PER_BLOCK; current_warp++) {
            output_data[current_block_offset + current_warp * ELEMENTS_PER_WARP + thread_index] = (warp_level[current_warp][thread_index] + block_prefix_sum) << STATUS_FLAG_LEN | STATUS_G;
            output_data[current_block_offset + current_warp * ELEMENTS_PER_WARP + THREADS_PER_WARP + thread_index] = (warp_level[current_warp][THREADS_PER_WARP + thread_index] + block_prefix_sum) << STATUS_FLAG_LEN | STATUS_G;
        }
    }
}
